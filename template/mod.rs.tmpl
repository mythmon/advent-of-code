use advent_lib::{
    cases::{GenericPuzzleCase, Puzzle, PuzzleCase, PuzzleRunner},
    helpers::StringAdventExt,
};
use std::iter::Iterator;

pub fn get_puzzles() -> Vec<Box<dyn Puzzle>> {
    vec![
        Box::new(Part1),
        // Box::new(Part2),
    ]
}

#[derive(Debug)]
pub struct Part1;

impl PuzzleRunner for Part1 {
    type Input = Vec<i32>;
    type Output = i32;

    fn name(&self) -> String {
        "{{YEAR}}-D{{DAY_PADDED}}-P1".to_owned()
    }

    fn cases(&self) -> Vec<Box<dyn PuzzleCase>> {
        GenericPuzzleCase::<Self, _, _>::build_set()
            .add_transform(parse_input)
            .case("Example", 42, None)
            .transformed_case("Solution", include_str!("input"), None)
            .collect()
    }

    fn run_puzzle(input: Self::Input) -> Self::Output {
        unimplemented!();
    }
}

// #[derive(Debug)]
// pub struct Part2;
//
// impl PuzzleRunner for Part2 {
//     type Input = Vec<i32>
//     type Output = i32;
//
//     fn name(&self) -> String {
//         "{{YEAR}}-D{{DAY_PADDED}}-P2".to_owned()
//     }
//
//     fn cases(&self) -> Vec<Box<dyn PuzzleCase>> {
//         GenericPuzzleCase::<Self, _, _>::build_set()
//             .add_transform(parse_input)
//             .case("Example", "example", None)
//             .transformed_case("Solution", include_str!("input"), None)
//             .collect()
//     }
//
//     fn run_puzzle(input: Self::Input) -> Self::Output {
//         unimplemented!();
//     }
// }

fn parse_input(input: &str) -> Vec<u32> {
    input
        .trimmed_lines()
        .map(|line| line.parse().unwrap())
        .collect()
}
